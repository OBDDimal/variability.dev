<!--EXECUTE: npx serve in transpiler folder to see visualisation -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script src="https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js"></script>
    <title>Test</title>
</head>

<body>
<div style="width: 100vw; height: 100vh" id="mountNode"></div>
<script defer>
    fetch("xmlExamples/g6_model.json")
        .then((res) => res.json())
        .then((data) => {
            const container = document.getElementById("mountNode");
            const width = container.scrollWidth;
            const height = container.scrollHeight || 500;
            const defaultRankSep = 180;
            const defaultFontSize = 11;
            const defaultNodeSize = [20, 20];
            const treeDir = "TB"; // H / V / LR / RL / TB / BT
            const strokeColor = '#a2a2a2';
            const concreteNodeColor = '#ccccff';
            const abstractNodeColor = '#f2f2ff';
            const graph = new G6.TreeGraph({
                container: "mountNode",
                width,
                height,
                linkCenter: true,
                modes: {
                    default: [
                        {
                            type: "collapse-expand",
                            enableDelegate: true,
                            trigger: "click",
                            //prevent collapsing/expanding on leaf nodes
                            shouldBegin: (e) => {
                                if (e.item && e.item.getModel().children.length) {
                                    return true;
                                }
                                return false;
                            },
                            relayout: true,
                        },
                        {
                            type: 'zoom-canvas',
                            enableOptimize: true,
                            //optimizeZoom: 0.9,
                        },
                        {
                            type: 'drag-canvas',
                            //enableOptimize: true, //do not show node label while dragging?
                        },
                    ],
                },
                defaultNode: {
                    type: 'rect',
                    size: defaultNodeSize, //default node size, will be overwritten later
                    labelCfg: {
                        style: {
                            fontSize: defaultFontSize,
                        }
                    },
                    anchorPoints: [
                        [0, 0.5],
                        [1, 0.5],
                    ],
                    style: {
                        fill: concreteNodeColor,
                        stroke: strokeColor,
                    },
                },
                defaultEdge: {
                    type: "cubic-vertical",
                },
                layout: {
                    type: "dendrogram",
                    direction: treeDir,
                    gpuEnabled: true,
                    workerEnabled: true,   //enable Web-Worker
                    preventOverlap: true,
                    nodeSep: 40,
                    rankSep: defaultRankSep,
                },
            });
            let maxSep = defaultRankSep;
            graph.data(data);

            //customize nodes
            graph.node(function (node) {
                if (!node.wasRendered) {
                    let fontSizeDuplicator = 7 //choosen via try and error
                    //label position relative to node, options: center, top, bottom, left, right
                    let labelPos = "center";
                    let rotate = 0;
                    //resize node according to label length
                    let newLabel = (node.fm_attributes.type != 'feature') ? node.fm_attributes.type + " | " + node.id : node.id;
                    let newWidth = (newLabel.length + 2) * fontSizeDuplicator;
                    let size = [newWidth, node.size[1]];

                    if (treeDir == "TB" && !node.children.length) {
                        //labelPos = "bottom"; //pos for label of node
                        rotate = Math.PI / 2;
                        //interchange width and height
                        size = [size[1], size[0]];
                    }
                    maxSep = (newWidth > maxSep ? newWidth : maxSep);

                    return {
                        id: node.id,
                        label: newLabel,
                        size: size,
                        wasRendered: true,
                        style: {
                            fill: (node.fm_attributes.abstract ? abstractNodeColor : concreteNodeColor),
                            stroke: strokeColor,
                        },
                        labelCfg: {
                            labelPos,
                            style: {
                                rotate,
                                fontFamily: 'courier'
                            },
                        },
                    };
                } else {
                    return node;
                }
            });
            //customize edges
            //built in mandatory attributes: id, source, target, type
            //fm_attributes mandatory with field type (can be 'and', 'or', 'feautre', ...)
            //Note that, if fm_attributes.type == 'and' then there can be a new attribute 'mandatory'
            //more: https://g6.antv.vision/en/docs/manual/middle/elements/edges/defaultEdge#the-common-property
            graph.edge((edge) => {
                let parent = graph.findById(edge.source);
                let currentDepth = graph.findById(edge.source).get('model').depth;
                //collapse subtrees on depth level 2
                //https://g6.antv.vision/en/docs/manual/middle/states/defaultBehavior#collapse-expand
                if (currentDepth == 2) {
                    let newModel = graph.findById(edge.source).get('model');
                    //do this only on init, means collapse is undefined
                    if (newModel.collapsed == undefined) {
                        newModel.collapsed = true;
                        graph.updateItem(parent, newModel);
                    }
                }
                let child = graph.findById(edge.target).get('model');
                parent = graph.findById(edge.source).get('model');
                switch (parent.fm_attributes.type) {
                    case 'and':
                        //add and color mandatory circle accordingly
                        return {
                            id: edge.id,
                            source: edge.source,
                            target: edge.target,
                            type: edge.type,
                            style: {
                                endArrow: {
                                    fill: (child.fm_attributes.mandatory ? '#000000' : '#ffffff'),
                                    path: G6.Arrow.circle(4, 8), //radius, offset
                                    d: 5
                                }
                            }
                        };
                    default:
                        return {
                            id: edge.id,
                            source: edge.source,
                            target: edge.target,
                            type: edge.type
                        };
                }
            });
            graph.layout(); //to activate the collapse information given above, see: https://g6.antv.vision/en/docs/manual/middle/states/defaultBehavior#collapse-expand
            graph.render();
            //graph.fitView(1337);
            graph.fitCenter(); //call this after render()
            graph.on('itemcollapsed', e => {
                if (e.collapsed) {
                    //collapsing node
                    console.log("collapsing node");
                } else {
                    //expanding node
                    console.log("expanding node");
                    console.log(e.item.getModel().size);
                }
            })
            graph.save();
            if (typeof window !== "undefined")
                window.onresize = () => {
                    if (!graph || graph.get("destroyed")) return;
                    if (
                        !container ||
                        !container.scrollWidth ||
                        !container.scrollHeight
                    )
                        return;
                    graph.changeSize(container.scrollWidth, container.scrollHeight);
                };
        });
</script>
</body>
</html>