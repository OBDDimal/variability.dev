<!--EXECUTE: npx serve in transpiler folder to see visualisation -->
<!--THIS FILE IS FOR TESTING PURPOSE ONLY AND CAN BE DELETED -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js"></script>
    <title>Test</title>
</head>

<body>
    <div style="width: 100vw; height: 100vh" id="mountNode"></div>
    <script defer>
        fetch("xmlExamples/g6_model_npc.json")
            .then((res) => res.json())
            .then((data) => {
                const container = document.getElementById("mountNode");
                const width = container.scrollWidth;
                const height = container.scrollHeight || 500;
                const defaultRankSep = 180;
                const treeDir = "TB"; // H / V / LR / RL / TB / BT
                const strokeColor = '#a2a2a2';
                const concreteNodeColor = '#ccccff';
                const abstractNodeColor = '#f2f2ff';
                const graph = new G6.TreeGraph({
                    container: "mountNode",
                    width,
                    height,
                    linkCenter: true,
                    modes: {
                        default: [
                            //'click-select',
                            {
                                type: "collapse-expand",
                                enableDelegate: true,
                                trigger: "click",
                                //only subtrees which leaf nodes only can be expanded or not   
                                shouldBegin: (e) => {
                                    if(e.item && e.item.getModel().children.length){
                                        node = e.item.getModel();
                                        currentChildren = node.children;
                                        leaves = node.children.filter(child => !child.children.length);
                                        return (leaves.length == currentChildren.length);
                                    }
                                    return false;
                                },
                            },
                            {
                                type: 'zoom-canvas',
                                enableOptimize: true,
                                //optimizeZoom: 0.9,
                            },
                            {
                                type: 'drag-canvas',
                               // enableOptimize: true,
                            },
                            /*
                            {
                                type: 'scroll-canvas',
                                enableOptimize: true,
                            },
                            */
                        ],
                    },                    
                    defaultNode: {
                        type: 'rect',
                        size: [20, 20], //default node size, will be overwritten later
                        anchorPoints: [
                            [0, 0.5],
                            [1, 0.5],
                        ],
                        style: {
                            fill: concreteNodeColor,
                            stroke: strokeColor,
                        },
                    },
                    defaultEdge: {
                        type: "cubic-vertical",
                    },
                    layout: {
                        type: "dendrogram", // is TreeGraph
                        direction: treeDir,
                        gpuEnabled: true,
                        preventOverlap: true,
                        nodeSep: 40,
                        rankSep: defaultRankSep,
                    },
                });
                let maxSep = defaultRankSep;
                graph.node(function (node) {
                    let fontSizeDuplicator = 7 //choosen via try and error
                    //label's position, options: center, top, bottom, left, right
                    let position = "center";
                    let rotate = 0;
                    //resize node according to label length
                    let newWidth = (node.id.length + 2) * fontSizeDuplicator;
                    let size = [newWidth, node.size[1]]
                    if (treeDir == "TB" && !node.children.length) {
                        //position = "bottom"; //pos for label of node
                        rotate = Math.PI / 2;
                        //interchange width and height
                        size = [size[1], size[0]];
                    }
                    maxSep = (newWidth > maxSep ? newWidth: maxSep) 

                    return {
                        label: node.id,
                        size: size,
                        style: {
                            fill: (node.fm_attributes.abstract ? abstractNodeColor : concreteNodeColor),
                            stroke: strokeColor,
                        },
                        //anchorPoints:(!node.children.length ? [1,1]: node.anchorPoints),
                        labelCfg: {
                            position,
                            //offset: 1,
                            style: {
                                rotate,
                                fontFamily: 'courier'
                            },
                        },
                    };
                });

                graph.data(data);
                graph.render();
                //console.log(maxSep);
                //graph.updateLayout({rankSep: maxSep});
                //graph.fitCenter();
                graph.fitView();
                graph.on('itemcollapsed', e => {
                    //console.log(e.item.getModel().size);
                    if(e.item.collapsed) {
                        //collapsing node
                        console.log("collapsing node");
                    } else {
                        //expanding node
                        console.log("expanding node");
                        console.log(e.item.getModel().size);
                    }
                })

/*
                // Click a node
                graph.on('node:click', (e) => {
                // Swich the 'click' state of the node to be false
                const clickNodes = graph.findAllByState('node', 'click');
                clickNodes.forEach((cn) => {
                    graph.setItemState(cn, 'click', false);
                });
                const nodeItem = e.item; // et the clicked item
                graph.setItemState(nodeItem, 'click', true); // Set the state 'click' of the item to be true
                });
*/
                if (typeof window !== "undefined")
                    window.onresize = () => {
                        if (!graph || graph.get("destroyed")) return;
                        if (
                            !container ||
                            !container.scrollWidth ||
                            !container.scrollHeight
                        )
                            return;
                        graph.changeSize(container.scrollWidth, container.scrollHeight);
                    };
            });
    </script>
</body>

</html>