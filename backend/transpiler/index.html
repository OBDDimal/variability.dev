<!--EXECUTE: npx serve in transpiler folder to see visualisation -->
<!--THIS FILE IS FOR TESTING PURPOSE ONLY AND CAN BE DELETED -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js"></script>
    <title>Test</title>
</head>

<body>
    <div style="width: 100vw; height: 100vh" id="mountNode"></div>
    <script defer>
        fetch("xmlExamples/g6_model_npc.json")
            .then((res) => res.json())
            .then((data) => {
                const container = document.getElementById("mountNode");
                const width = container.scrollWidth;
                const height = container.scrollHeight || 500;
                const defaultRankSep = 180;
                const defaultFontSize = 11;
                const defaultNodeSize = [20, 20];
                const treeDir = "TB"; // H / V / LR / RL / TB / BT
                const strokeColor = '#a2a2a2';
                const concreteNodeColor = '#ccccff';
                const abstractNodeColor = '#f2f2ff';
                const graph = new G6.TreeGraph({
                    container: "mountNode",
                    width,
                    height,
                    linkCenter: true,
                    modes: {
                        default: [
                            //'click-select',
                            {
                                type: "collapse-expand",
                                enableDelegate: true,
                                trigger: "click",
                                //only subtrees with leaf nodes only can be expanded or not   
                                shouldBegin: (e) => {
                                    if (e.item && e.item.getModel().children.length) {
                                        node = e.item.getModel();
                                        currentChildren = node.children;
                                        leaves = node.children.filter(child => !child.children.length);
                                        return (leaves.length == currentChildren.length);
                                    }
                                    return false;
                                },
                                relayout: true,
                            },
                            {
                                type: 'zoom-canvas',
                                enableOptimize: true,
                                //optimizeZoom: 0.9,
                            },
                            {
                                type: 'drag-canvas',
                                direction: 'x',
                                // enableOptimize: true,
                            },
                            /*
                            {
                                type: 'scroll-canvas',
                                enableOptimize: true,
                            },
                            */
                        ],
                    },
                    defaultNode: {
                        type: 'rect',
                        size: defaultNodeSize, //default node size, will be overwritten later
                        labelCfg: {
                            style: {
                                fontSize: defaultFontSize,
                            }
                        },
                        anchorPoints: [
                            [0, 0.5],
                            [1, 0.5],
                        ],
                        style: {
                            fill: concreteNodeColor,
                            stroke: strokeColor,
                        },
                    },
                    defaultEdge: {
                        type: "cubic-vertical",
                    },
                    layout: {
                        type: "dendrogram", // is TreeGraph
                        direction: treeDir,
                        gpuEnabled: true,
                        preventOverlap: true,
                        nodeSep: 40,
                        rankSep: defaultRankSep,
                    },
                });
                let maxSep = defaultRankSep;
                graph.data(data);
                //customize nodes
                graph.node(function (node) {
                    if (!node.wasRendered) {
                        let fontSizeDuplicator = 7 //choosen via try and error
                        //label's position, options: center, top, bottom, left, right
                        let position = "center";
                        let rotate = 0;
                        //resize node according to label length
                        let newLabel = (node.fm_attributes.type != 'feature' && node.fm_attributes.type != 'and') ? node.fm_attributes.type  + " | " + node.id : node.id;
                        let newWidth = (newLabel.length + 2) * fontSizeDuplicator;
                        let size = [newWidth, node.size[1]];

                        //console.log(node.id + " old size " + node.size + " ? " + node.wasRendered);
                        if (treeDir == "TB" && !node.children.length) {
                            //position = "bottom"; //pos for label of node
                            rotate = Math.PI / 2;
                            //interchange width and height
                            size = [size[1], size[0]];
                        }
                        maxSep = (newWidth > maxSep ? newWidth : maxSep);
                        switch (node.fm_attributes.type) {
                            default:
                                return {
                                    id: node.id,
                                    label: newLabel,
                                    size: size,
                                    wasRendered: true,
                                    style: {
                                        fill: (node.fm_attributes.abstract ? abstractNodeColor : concreteNodeColor),
                                        stroke: strokeColor,
                                    },
                                    //anchorPoints:(!node.children.length ? [1,1]: node.anchorPoints),
                                    labelCfg: {
                                        position,
                                        //offset: 1,
                                        style: {
                                            rotate,
                                            fontFamily: 'courier'
                                        },
                                    },
                                };
                        }
                    } else {
                        return node;
                    }
                });
                //customize edges
                //built in mandatory attributes: id, source, target, type
                //fm_attributes mandatory with field type (can be 'and', 'or', 'feautre', ...)
                //Note that, if fm_attributes.type == 'and' then there can be a new attribute 'mandatory'
                //more: https://g6.antv.vision/en/docs/manual/middle/elements/edges/defaultEdge#the-common-property 
                graph.edge((edge) => {
                    let parent = graph.findById(edge.source);
                    let currentDepth = graph.findById(edge.source).get('model').depth;
                    console.log("parent depth= " +currentDepth);
                    //collapse every node where depth > 1
                    if(currentDepth == 1) {
                        let newModel = graph.findById(edge.source).get('model');
                        //do this only on init, means collapse is undefined
                        if(newModel.collapsed == undefined) {
                            newModel.collapsed = true;
                            graph.updateItem(parent, newModel);
                        }
                    }
                    let child = graph.findById(edge.target).get('model');
                    parent = graph.findById(edge.source).get('model');
                    switch (parent.fm_attributes.type) {
                        case 'and':
                            //add and color mandatory circle accordingly
                            return {
                                id: edge.id,
                                source: edge.source,
                                target: edge.target,
                                type: edge.type,
                                style: {
                                    endArrow: {
                                        fill: (child.fm_attributes.mandatory ? '#000000' : '#ffffff'),
                                        path: G6.Arrow.circle(4, 8), //radius, offset
                                        d: 5
                                    }
                                }
                            };
                        default:
                            return {
                                id: edge.id,
                                source: edge.source,
                                target: edge.target,
                                type: edge.type
                            };
                    }
                });
                graph.layout(); //to activate the collapse information given above, see: https://g6.antv.vision/en/docs/manual/middle/states/defaultBehavior#collapse-expand
                graph.render();
                //console.log(maxSep);
                //graph.updateLayout({rankSep: maxSep});
                //graph.fitCenter();
                graph.fitView();
                graph.on('itemcollapsed', e => {
                    if (e.item.collapsed) {
                        //collapsing node
                        console.log("collapsing node");
                    } else {
                        //expanding node
                        console.log("expanding node");
                        console.log(e.item.getModel().size);
                    }
                })

                /*
                                // Click a node
                                graph.on('node:click', (e) => {
                                // Swich the 'click' state of the node to be false
                                const clickNodes = graph.findAllByState('node', 'click');
                                clickNodes.forEach((cn) => {
                                    graph.setItemState(cn, 'click', false);
                                });
                                const nodeItem = e.item; // et the clicked item
                                graph.setItemState(nodeItem, 'click', true); // Set the state 'click' of the item to be true
                                });
                */
                if (typeof window !== "undefined")
                    window.onresize = () => {
                        if (!graph || graph.get("destroyed")) return;
                        if (
                            !container ||
                            !container.scrollWidth ||
                            !container.scrollHeight
                        )
                            return;
                        graph.changeSize(container.scrollWidth, container.scrollHeight);
                    };
            });
    </script>
</body>

</html>